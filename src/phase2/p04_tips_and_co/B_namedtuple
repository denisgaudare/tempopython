## âœ… Exemple : ModÃ©liser un vol avec `namedtuple`

```python
from collections import namedtuple

# CrÃ©ation du type Vol avec 4 champs
Vol = namedtuple('Vol', ['code', 'origine', 'destination', 'retard_min'])

# Instanciation dâ€™un vol
vol1 = Vol(code='AF123', origine='CDG', destination='JFK', retard_min=15)

# AccÃ¨s aux donnÃ©es par nom de champ
print(f"Vol {vol1.code} de {vol1.origine} vers {vol1.destination}")
print(f"Retard estimÃ© : {vol1.retard_min} minutes")

# AccÃ¨s par index (comme un tuple classique)
print(vol1[0])  # 'AF123'

# DÃ©structuration possible
code, origine, destination, retard = vol1
print(destination)  # JFK

# CrÃ©ation Ã  partir dâ€™un iterable
data = ['BA456', 'LHR', 'DXB', 0]
vol2 = Vol._make(data)

# Conversion en dict pour export JSON, par exemple
print(vol2._asdict())
```
---

## ğŸ§  Pourquoi utiliser `namedtuple` ?

- âœ… Immuable (comme un tuple)
- âœ… AccÃ¨s **lisible** via des **noms de champs**
- âœ… Moins lourd que `class + __init__`
- âœ… Compatible avec le typage statique (`typing.NamedTuple`)

---

## ğŸš€ Bonus : version typÃ©e (Python 3.6+)

```python
from typing import NamedTuple

class Vol(NamedTuple):
    code: str
    origine: str
    destination: str
    retard_min: int
```
---

## ğŸ†š `namedtuple` vs `dataclass`

| CritÃ¨re                     | `namedtuple`                            | `dataclass` (Python 3.7+)                |
|----------------------------|------------------------------------------|------------------------------------------|
| Syntaxe                    | HÃ©ritÃ© de `collections` ou `typing`     | Mot-clÃ© `@dataclass`                     |
| Immuable par dÃ©faut        | âœ… Oui (`tuple` immuable)               | âŒ Non, mais peut Ãªtre rendu immuable    |
| AccÃ¨s par nom              | âœ… Oui                                   | âœ… Oui                                   |
| Type hint                  | ğŸŸ¡ Partiel (`typing.NamedTuple`)         | âœ… Complet                               |
| Valeurs par dÃ©faut         | âŒ Non (possible mais verbeux)           | âœ… Oui, trÃ¨s facile                      |
| MÃ©thodes personnalisÃ©es    | âŒ Complexe Ã  ajouter                    | âœ… Naturelles avec des mÃ©thodes de classe |
| MutabilitÃ©                 | âŒ Non (doit recrÃ©er lâ€™objet)            | âœ… Par dÃ©faut                            |
| MÃ©thodes auto-gÃ©nÃ©rÃ©es     | `.asdict()`, `.make()`                   | `__init__`, `__repr__`, `__eq__`, etc.  |
| Performance                | âœ… TrÃ¨s lÃ©ger et rapide                  | ğŸŸ¡ Moins rapide mais plus flexible       |

---

## ğŸ§ª Exemples comparÃ©s

### ğŸ”¸ `namedtuple`

```python
from collections import namedtuple

Vol = namedtuple('Vol', ['code', 'origine', 'destination'])

v = Vol('AF123', 'CDG', 'JFK')
print(v.code)  # AF123
```

### ğŸ”¹ `dataclass`

```python
from dataclasses import dataclass

@dataclass
class Vol:
    code: str
    origine: str
    destination: str
    retard: int = 0  # valeur par dÃ©faut

v = Vol('AF123', 'CDG', 'JFK')
print(v.code)  # AF123
v.retard = 15  # possible car mutable
```

---

## ğŸ”’ Rendre une `dataclass` immuable

```python
@dataclass(frozen=True)
class Vol:
    code: str
    origine: str
    destination: str
```

---

## ğŸ§  En rÃ©sumÃ© :

| Tu veux...                            | Utilise...     |
|--------------------------------------|----------------|
| Un conteneur simple, immutable, rapide | `namedtuple`   |
| Une structure modifiable et Ã©volutive  | `@dataclass`   |
| Du typage, des valeurs par dÃ©faut, des mÃ©thodes | `@dataclass`   |

---
